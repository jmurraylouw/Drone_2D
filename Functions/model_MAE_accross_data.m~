function results = model_MAE_accross_data(y_data, u_data, t, A, B, N_test, model_type, plot_and_pause, plot_results)
%% Get Mean Absolute Error of model predicted forward by N_test 
%% from every time step in dataset
% i.e. Evaluate performance of model at different times during simulation
% results = Table of MAE scores for each time step, k
% y_data  = output data from simulation to compare to
% u_data  = input data from simulation
% t       = time data of sim
% A       = System matrix of model
% B       = input matrix of model
% N_test  = number of data samples to predict forward when calculating MAE
% model_type = 'delay_A' for delays accounted for in A, or 'delay_B'

N = length(t); % Total number of data samples
ny = size(y_data,1);
q = size(A,1)/ny; % Number of delay coordinates in model

% Create empty results table
VariableTypes = {'int16', 'double'}; % id, q, MAE_mean
VariableNames = {'k',     'MAE_mean'};
for i = 1:ny % Mae column for each measured state
    VariableNames = [VariableNames, strcat('MAE_', num2str(i))];
    VariableTypes = [VariableTypes, 'double'];
end
Size = [N, length(VariableTypes)];

results = table('Size',Size,'VariableTypes',VariableTypes,'VariableNames',VariableNames);
emptry_row = 1; % Keep track of next empty row to insert results 

for k = 1:length(t)
    % Data to test with, starting at sample k           
    y_run = y_data(:, k + (0:N_test-1));
    u_run = u_data(:, k + (0:N_test-1));
    t_run =      t(:, k + (0:N_test-1));

    % Initial condition
    y_hat_0 = y_data(:,k);

    % Initial delay coordinates
    y_delays = zeros((q-1)*ny, 1);
    j = k; % index of y_data
    for i = 1:ny:ny*(q-1) % index of y_delays
        j = j - 1; % previos index of y_data
        if j < 1 % Assume for time steps before k=1, y = initial condition
            j = 1;
        end        
        y_delays(i:(i+ny-1)) = y_data(:,j); % Insert into delay vector
    end

    % Run model predictions
    switch model_type
        case 'delay_A'
            y_hat = zeros(q*ny, N_test); % Empty estimated Y
            y_hat(:,1) = [y_hat_0; y_delays]; % Initial condition
            for j = 1:N_test-1
                y_hat(:,j+1) = A*y_hat(:,j) + B*u_run(:,j);
            end
            y_hat = y_hat(1:ny, :); % Only keep non-delay rows
            
        case 'delay_B'
            y_hat = zeros(ny,N_test); % Empty estimated Y
            y_hat(:,1) = y_hat_0; % Initial condition
            for j = 1:N_test-1
                upsilon = [y_delays; u_run(:,j)]; % Concat delays and control for use with B
                y_hat(:,j+1) = A*y_hat(:,j) + B*upsilon;
                y_delays = [y_hat(:,j); y_delays(1:(end-ny),:)]; % Add y(k) to y_delay for next step [y(k); y(k-1); ...]
            end
            
        otherwise
            error("Use either 'delay_A' or 'delay_B' ")
            
    end % switch

    % Vector of Mean Absolute Error on testing data
    MAE = sum(abs(y_hat - y_run), 2)./N_test; % For each measured state

    % Save results
    results(emptry_row,:) = [{k, mean(MAE)}, num2cell(MAE')]; % add to table of results
    emptry_row = emptry_row + 1; 

    % Plot and pause at every timestep
    if plot_and_pause
        figure(1)
        ylim;
        hold on;
        plot(t_run, y_run)
        ylim
        plot(t_run, y_hat, 'r')
        hold off;
        disp('Pausing... Press enter to continue')
        pause
        clf('reset')
        disp('Continuing...')
    end
    
end % k

if plot_results
    figure
    semilogy(t(results.k), results.MAE_mean)
    title("Model error over time")
    
    figure
    plot(t(results.k), results.MAE_mean*100)
    hold on
    title("Model error vs states")
    plot(t, y_data)
    legend('mean MAE scaled', 'x', 'z', 'theta')
    hold off
end
